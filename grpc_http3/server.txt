use tonic::{transport::Server, Request, Response, Status};

use hello_world::greeter_server::{Greeter, GreeterServer};
use hello_world::{HelloReply, HelloRequest};

use tokio::sync::mpsc;
use tokio::net::UdpSocket;
use tokio::io::DuplexStream;
use std::collections::HashMap;
use tokio::task;
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::sync::Mutex;
use std::net::SocketAddr;
use tokio::time::{sleep, Duration};

struct Client {
    stream: DuplexStream,
}

type ClientMap = HashMap<std::net::SocketAddr, Client>;

pub mod hello_world {
    tonic::include_proto!("helloworld");
}

#[derive(Default)]
pub struct MyGreeter {}

#[tonic::async_trait]
impl Greeter for MyGreeter {
    async fn say_hello(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<HelloReply>, Status> {
        println!("Got a request from {:?}", request.remote_addr());

        let reply = hello_world::HelloReply {
            message: format!("Hello {}!", request.into_inner().name),
        };
        println!("Replying with {:?}", reply);
        Ok(Response::new(reply))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr : String = "127.0.0.1:4433".parse().unwrap();
    let greeter = MyGreeter::default(); //Define the gRPC service

    println!("GreeterServer listening on {}", addr);
    
    let (tx, recv) = mpsc::unbounded_channel::<Result<DuplexStream, String>>();
    let clients = Arc::new(Mutex::new(ClientMap::new())); //HashMap that stores clients ip and their corresponding DuplexStream
    let clients2 = clients.clone();
    let socket = UdpSocket::bind("127.0.0.1:4433".parse::<SocketAddr>().unwrap()).await?;
    let r = Arc::new(socket);
    let s = r.clone();

    let timeout = Duration::from_millis(10); 

    task::spawn(async move { //Task that handles the reading of the UDP traffic
        
        let mut buf = [0; 65535];
    
        loop {
            'read: loop { //Read loop that reads UDP traffic and feed it to gRPC
                println!("Read loop");
                
                let (len, from) = match r.recv_from(&mut buf).await {
                    Ok(v) => v,

                    Err(e) => {
                        println!("Nothing to read: {:?}", e);
                        sleep(timeout).await; // Wait a bit before trying again
                        break 'read;
                    },
                };

                let mut new_client = None;
                let mut add = None;

                match clients.lock().await.get_mut(&from) { // Check if the client is already known - if not, create a new one
                    Some(client) => { //Already known client
                        let out = &buf[..len];
                        println!("Received {} bytes from {:?}", out.len(), from);
                        client.stream.write(out).await.unwrap(); //Send data to the gRPC server
                    },
                    None => { //New client
                        let (mut send, rcv) = tokio::io::duplex(128); //Create new DuplexStream
                        let out = &buf[..len];
                        send.write(out).await.unwrap();
                        println!("Received {} bytes from {:?}", out.len(), from);
                        tx.send(Ok(rcv)).unwrap(); // Send the DuplexStream to the gRPC server
                        new_client = Some(Client {
                            stream: send,
                        });
                        add = Some(from);
                    }
                }

                if let Some(client) = new_client {
                    if let Some(from) = add {
                        clients.lock().await.insert(from, client); //Add the new client to the clients hashmap 
                    }
                }

        }}});

    task::spawn(async move { //Task that handles the sending of the gRPC data to the UDP socket
        loop{
            println!("Write loop");
            sleep(Duration::from_millis(10)).await;
            for (ip, client) in clients2.lock().await.iter_mut() { //Problem: <-- take the lock here
                let mut buffer = [0; 65535];
                match client.stream.read(&mut buffer).await { // <-- Block on the wait here - the lock is still taken
                    Ok(0) => {
                        println!("Nothing to send to client ");
                    },
                    Ok(n) => {
                        println!("Put {} bytes in the sync buffer", n);
                        s.send_to(&buffer[..n], *ip).await.unwrap();
                    },
                    Err(e) => {
                        println!("Error reading : {:?}", e);
                    }
                }
            }
        }
    });
    

    Server::builder()
        .add_service(GreeterServer::new(greeter))
        .serve_with_incoming(tokio_stream::wrappers::UnboundedReceiverStream::new(recv))
        .await?;


    Ok(())
}

